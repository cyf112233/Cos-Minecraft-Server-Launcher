package byd.cxkcxkckx.mcserver.utils

import byd.cxkcxkckx.mcserver.data.ServerConfig
import byd.cxkcxkckx.mcserver.data.ServerInfo
import byd.cxkcxkckx.mcserver.data.ServerStats
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.BufferedReader
import java.io.BufferedWriter
import java.io.File
import java.io.InputStreamReader
import java.io.OutputStreamWriter
import java.nio.charset.Charset
import kotlin.concurrent.thread

enum class ServerState {
    STOPPED,
    STARTING,
    RUNNING,
    STOPPING,
    ERROR
}

data class ServerProcess(
    val serverInfo: ServerInfo,
    val process: Process,
    val outputReader: BufferedReader,
    val inputWriter: BufferedWriter,
    var startTime: Long = System.currentTimeMillis()
)

object ServerRunner {
    private val runningServers = mutableMapOf<String, ServerProcess>()
    private const val DEBUG = true
    
    private fun log(message: String) {
        if (DEBUG) {
            println("[ServerRunner] $message")
        }
    }
    
    /**
     * Check if EULA is accepted
     */
    suspend fun checkEula(serverPath: String): Boolean = withContext(Dispatchers.IO) {
        log("Checking EULA at: $serverPath")
        val eulaFile = File(serverPath, "eula.txt")
        if (!eulaFile.exists()) {
            log("EULA file not found")
            return@withContext false
        }
        
        try {
            val content = eulaFile.readText()
            val accepted = content.contains("eula=true", ignoreCase = true)
            log("EULA accepted: $accepted")
            return@withContext accepted
        } catch (e: Exception) {
            log("Error reading EULA: ${e.message}")
            return@withContext false
        }
    }
    
    /**
     * Accept EULA and write to file
     */
    suspend fun acceptEula(serverPath: String): Boolean = withContext(Dispatchers.IO) {
        log("Accepting EULA at: $serverPath")
        val eulaFile = File(serverPath, "eula.txt")
        try {
            val content = buildString {
                appendLine("# By changing the setting below to TRUE you are indicating your agreement to our EULA (https://www.minecraft.net/zh-hans/eula).")
                appendLine("# Generated by Cosp Minecraft Server Launcher")
                appendLine("# ${java.time.LocalDateTime.now()}")
                appendLine("eula=true")
            }
            eulaFile.writeText(content)
            log("EULA accepted successfully")
            return@withContext true
        } catch (e: Exception) {
            log("Error accepting EULA: ${e.message}")
            e.printStackTrace()
            return@withContext false
        }
    }
    
    /**
     * Start server with UTF-8 encoding
     */
    suspend fun startServer(serverInfo: ServerInfo): Result<ServerProcess> = withContext(Dispatchers.IO) {
        log("Starting server: ${serverInfo.name} (${serverInfo.id})")
        
        try {
            // Check if server is already running
            if (runningServers.containsKey(serverInfo.id)) {
                log("Server already running: ${serverInfo.id}")
                return@withContext Result.failure(Exception("Server already running"))
            }
            
            // Initialize state to STARTING
            ServerStateManager.updateState(serverInfo.id, ServerState.STARTING)
            
            // Check server directory
            val serverDir = File(serverInfo.path)
            if (!serverDir.exists() || !serverDir.isDirectory) {
                log("Server directory not found: ${serverInfo.path}")
                ServerStateManager.updateState(serverInfo.id, ServerState.ERROR)
                return@withContext Result.failure(Exception("Server directory not found"))
            }
            log("Server directory: ${serverDir.absolutePath}")
            
            // Find server JAR file
            val jarFile = findServerJar(serverDir)
            if (jarFile == null || !jarFile.exists()) {
                log("Server JAR file not found in: ${serverDir.absolutePath}")
                ServerStateManager.updateState(serverInfo.id, ServerState.ERROR)
                return@withContext Result.failure(Exception("Server JAR file not found"))
            }
            log("Found server JAR: ${jarFile.name}")
            
            // Build start command
            val command = serverInfo.config.generateStartCommand(jarFile.name)
            log("Start command: ${command.joinToString(" ")}")
            
            // Create process
            val processBuilder = ProcessBuilder(command)
                .directory(serverDir)
                .redirectErrorStream(true)

            // Set environment variables for UTF-8 support (subprocess only, won't affect system)
            val env = processBuilder.environment()
            val osName = System.getProperty("os.name").lowercase()
            if (osName.contains("windows")) {
                // Windows: Force UTF-8 encoding for Java subprocess
                env["JAVA_TOOL_OPTIONS"] = "-Dfile.encoding=UTF-8 -Dconsole.encoding=UTF-8 -Dsun.stdout.encoding=UTF-8 -Dsun.stderr.encoding=UTF-8"
                env["_JAVA_OPTIONS"] = "-Dfile.encoding=UTF-8"
                log("Set Windows UTF-8 environment variables for subprocess")
            } else {
                // Linux/Mac: Force UTF-8 locale
                env["LANG"] = "zh_CN.UTF-8"
                env["LC_ALL"] = "zh_CN.UTF-8"
                log("Set Unix UTF-8 environment variables for subprocess")
            }

            log("Starting process...")
            val process = processBuilder.start()
            log("Process started, PID: ${process.pid()}")

            // Create input/output streams with UTF-8 encoding
            val outputReader = BufferedReader(InputStreamReader(process.inputStream, Charsets.UTF_8))
            val inputWriter = BufferedWriter(OutputStreamWriter(process.outputStream, Charsets.UTF_8))
            log("I/O streams created with UTF-8 encoding")
            
            // Create server process object
            val serverProcess = ServerProcess(
                serverInfo = serverInfo,
                process = process,
                outputReader = outputReader,
                inputWriter = inputWriter,
                startTime = System.currentTimeMillis()
            )
            
            // Add to running list
            runningServers[serverInfo.id] = serverProcess
            log("Server added to running list: ${serverInfo.id}")
            
            // Start log reader thread
            startLogReader(serverProcess)

            // Start process monitor thread
            startProcessMonitor(serverProcess)
            
            // Start stats updater thread
            startStatsUpdater(serverProcess)

            // Wait briefly to check if process starts successfully
            log("Server startup initiated, waiting for confirmation...")
            var waited = 0
            val maxWaitSeconds = 8
            while (waited < maxWaitSeconds) {
                val currentState = ServerStateManager.getState(serverInfo.id)
                
                // If the process has become RUNNING, return success
                if (currentState == ServerState.RUNNING) {
                    log("Server started successfully")
                    return@withContext Result.success(serverProcess)
                }

                // If process has already exited, consider it a failure
                if (!serverProcess.process.isAlive) {
                    log("Process exited prematurely during startup")
                    val stateInfo = ServerStateManager.getStateInfo(serverInfo.id)
                    val lastLogs = stateInfo?.logs?.takeLast(20)?.joinToString("\n") ?: "No logs available"
                    ServerStateManager.updateState(serverInfo.id, ServerState.ERROR)
                    return@withContext Result.failure(Exception("Server process exited during startup. Recent logs:\n$lastLogs"))
                }

                Thread.sleep(1000)
                waited++
            }

            // If still starting after timeout, return success but UI should continue to observe
            log("Server still starting after $maxWaitSeconds seconds; returning startup pending")
            return@withContext Result.success(serverProcess)
        } catch (e: Exception) {
            log("Error starting server: ${e.message}")
            e.printStackTrace()
            ServerStateManager.updateState(serverInfo.id, ServerState.ERROR)
            return@withContext Result.failure(e)
        }
    }
    
    /**
     * Stop server gracefully
     */
    suspend fun stopServer(serverId: String): Boolean = withContext(Dispatchers.IO) {
        log("Stopping server: $serverId")
        val serverProcess = runningServers[serverId] ?: run {
            log("Server not found in running list: $serverId")
            return@withContext false
        }
        
        try {
            // Set stopping state
            ServerStateManager.updateState(serverId, ServerState.STOPPING)
            log("Server state set to STOPPING")
            
            // Send stop command
            sendCommand(serverId, "stop")
            log("Stop command sent")
            
            // Process monitor will handle cleanup when process exits
            log("stopServer completed, process monitor will handle cleanup")
            
            return@withContext true
        } catch (e: Exception) {
            log("Error stopping server: ${e.message}")
            e.printStackTrace()
            ServerStateManager.updateState(serverId, ServerState.ERROR)
            return@withContext false
        }
    }
    
    /**
     * Force kill server immediately
     */
    suspend fun forceKillServer(serverId: String): Boolean = withContext(Dispatchers.IO) {
        log("Force killing server: $serverId")
        val serverProcess = runningServers[serverId] ?: run {
            log("Server not found in running list: $serverId")
            return@withContext false
        }
        
        try {
            // Set to STOPPED state immediately
            ServerStateManager.updateState(serverId, ServerState.STOPPED)
            log("Server state set to STOPPED (force kill)")
            
            // Force kill process
            if (serverProcess.process.isAlive) {
                log("Force terminating process")
                serverProcess.process.destroyForcibly()
                log("Process force killed")
            } else {
                log("Process already dead")
            }
            
            // Process monitor will handle cleanup
            log("forceKillServer completed, process monitor will handle cleanup")
            
            return@withContext true
        } catch (e: Exception) {
            log("Error force killing server: ${e.message}")
            e.printStackTrace()
            ServerStateManager.updateState(serverId, ServerState.ERROR)
            return@withContext false
        }
    }
    
    /**
     * Send command to server
     */
    suspend fun sendCommand(serverId: String, command: String): Boolean = withContext(Dispatchers.IO) {
        log("Sending command to $serverId: $command")
        val serverProcess = runningServers[serverId] ?: run {
            log("Server not found: $serverId")
            return@withContext false
        }
        
        try {
            serverProcess.inputWriter.write(command)
            serverProcess.inputWriter.newLine()
            serverProcess.inputWriter.flush()
            log("Command sent successfully")
            return@withContext true
        } catch (e: Exception) {
            log("Error sending command: ${e.message}")
            e.printStackTrace()
            return@withContext false
        }
    }
    
    /**
     * Get server process
     */
    fun getServerProcess(serverId: String): ServerProcess? {
        return runningServers[serverId]
    }
    
    /**
     * Check if server is running
     */
    fun isServerRunning(serverId: String): Boolean {
        val process = runningServers[serverId]
        return process != null && process.process.isAlive
    }
    
    /**
     * Find server JAR file
     */
    private fun findServerJar(serverDir: File): File? {
        log("Searching for server JAR in: ${serverDir.absolutePath}")
        
        // Priority: server.jar
        val serverJar = File(serverDir, "server.jar")
        if (serverJar.exists()) {
            log("Found server.jar")
            return serverJar
        }
        
        // Find other JAR files
        val jarFiles = serverDir.listFiles { file ->
            file.extension.equals("jar", ignoreCase = true) &&
            !file.name.contains("libraries", ignoreCase = true)
        }
        
        log("Found ${jarFiles?.size ?: 0} JAR files")
        jarFiles?.forEach { log("  - ${it.name}") }
        
        return jarFiles?.firstOrNull()
    }
    
    /**
     * Start log reader thread
     */
    private fun startLogReader(serverProcess: ServerProcess) {
        log("Starting log reader for: ${serverProcess.serverInfo.id}")
        
        Thread {
            try {
                val serverId = serverProcess.serverInfo.id
                var line: String?
                var lineCount = 0
                
                log("Log reader thread started")
                
                while (serverProcess.process.isAlive) {
                    line = serverProcess.outputReader.readLine()
                    if (line != null) {
                        lineCount++
                        
                        // Append log via state manager
                        ServerStateManager.appendLog(serverId, line)
                        
                        // Log every 10 lines for debugging
                        if (lineCount % 10 == 0) {
                            log("Read $lineCount lines so far")
                        }
                        
                        // Detect server startup completion
                        val lowerLine = line.lowercase()
                        if ((lowerLine.contains("done") && lowerLine.contains("for help")) ||
                            lowerLine.contains("timings reset") ||
                            (lowerLine.contains("done") && lowerLine.contains("(") && lowerLine.contains("s)")) ||
                            lowerLine.contains("server started")) {
                            
                            log("Server startup detected! Current state: ${ServerStateManager.getState(serverId)}")
                            log("Trigger line: $line")
                            
                            if (ServerStateManager.getState(serverId) == ServerState.STARTING) {
                                ServerStateManager.updateState(serverId, ServerState.RUNNING)
                                log("Server state changed to RUNNING")
                            }
                        }
                        
                        // Parse player events
                        parsePlayerEvents(line, serverId)
                        
                        // Parse TPS information
                        parseTpsInfo(line, serverId)
                        
                        // Parse memory info
                        parseMemoryInfo(line, serverId)
                    } else {
                        // End of stream
                        log("End of log stream reached")
                        break
                    }
                }
                
                log("Log reader thread ending, total lines read: $lineCount")
            } catch (e: Exception) {
                log("Error in log reader: ${e.message}")
                e.printStackTrace()
            }
        }.apply {
            name = "LogReader-${serverProcess.serverInfo.id}"
            isDaemon = true
        }.start()
    }
    
    /**
     * Parse player join/leave events from logs
     */
    private fun parsePlayerEvents(line: String, serverId: String) {
        try {
            val lowerLine = line.lowercase()
            
            // Player joined
            if (lowerLine.contains("joined the game") || lowerLine.contains("logged in")) {
                ServerStateManager.updateStatsPartial(serverId) { current ->
                    current.copy(
                        onlinePlayers = (current.onlinePlayers + 1).coerceAtMost(current.maxPlayers)
                    )
                }
                log("Player joined, online: ${ServerStateManager.getStateInfo(serverId)?.stats?.onlinePlayers}")
            }
            
            // Player left
            if (lowerLine.contains("left the game") || lowerLine.contains("logged out") || 
                lowerLine.contains("disconnected")) {
                ServerStateManager.updateStatsPartial(serverId) { current ->
                    current.copy(
                        onlinePlayers = (current.onlinePlayers - 1).coerceAtLeast(0)
                    )
                }
                log("Player left, online: ${ServerStateManager.getStateInfo(serverId)?.stats?.onlinePlayers}")
            }
            
            // Parse max players
            val maxPlayersMatch = Regex("max.*players.*[:\\s]+(\\d+)", RegexOption.IGNORE_CASE).find(line)
            if (maxPlayersMatch != null) {
                val maxPlayers = maxPlayersMatch.groupValues[1].toIntOrNull()
                if (maxPlayers != null) {
                    ServerStateManager.updateStatsPartial(serverId) { current ->
                        current.copy(maxPlayers = maxPlayers)
                    }
                    log("Max players set to: $maxPlayers")
                }
            }
        } catch (e: Exception) {
            // Ignore parse errors
        }
    }
    
    /**
     * Parse TPS information from logs
     */
    private fun parseTpsInfo(line: String, serverId: String) {
        try {
            val tpsMatch = Regex("tps.*?([0-9]+\\.[0-9]+)", RegexOption.IGNORE_CASE).find(line)
            if (tpsMatch != null) {
                val tps = tpsMatch.groupValues[1].toDoubleOrNull()
                if (tps != null && tps <= 20.0) {
                    ServerStateManager.updateStatsPartial(serverId) { current ->
                        current.copy(tps = tps)
                    }
                    log("TPS updated: $tps")
                }
            }
        } catch (e: Exception) {
            // Ignore parse errors
        }
    }
    
    /**
     * Parse memory information from logs
     */
    private fun parseMemoryInfo(line: String, serverId: String) {
        try {
            val memoryMatch = Regex("(\\d+)\\s*(?:m|mb).*?(\\d+)\\s*(?:m|mb|g|gb)", RegexOption.IGNORE_CASE).find(line)
            if (memoryMatch != null) {
                val used = memoryMatch.groupValues[1].toLongOrNull()
                val total = memoryMatch.groupValues[2].toLongOrNull()
                if (used != null && total != null) {
                    ServerStateManager.updateStatsPartial(serverId) { current ->
                        current.copy(
                            usedMemoryMB = used,
                            maxMemoryMB = if (total > 100) total else total * 1024
                        )
                    }
                    log("Memory updated: ${used}MB / ${total}MB")
                }
            }
        } catch (e: Exception) {
            // Ignore parse errors
        }
    }
    
    /**
     * Start stats updater thread
     */
    private fun startStatsUpdater(serverProcess: ServerProcess) {
        thread(name = "StatsUpdater-${serverProcess.serverInfo.id}", isDaemon = true) {
            try {
                val serverId = serverProcess.serverInfo.id
                
                while (serverProcess.process.isAlive) {
                    // Update uptime every second
                    val uptimeSeconds = (System.currentTimeMillis() - serverProcess.startTime) / 1000
                    
                    ServerStateManager.updateStatsPartial(serverId) { current ->
                        current.copy(uptimeSeconds = uptimeSeconds)
                    }
                    
                    // Get memory info from JVM if not set
                    val currentStats = ServerStateManager.getStateInfo(serverId)?.stats
                    if (currentStats?.maxMemoryMB == 0L) {
                        try {
                            val runtime = Runtime.getRuntime()
                            val usedMemory = (runtime.totalMemory() - runtime.freeMemory()) / (1024 * 1024)
                            val maxMemory = runtime.maxMemory() / (1024 * 1024)
                            
                            ServerStateManager.updateStatsPartial(serverId) { current ->
                                current.copy(
                                    usedMemoryMB = usedMemory,
                                    maxMemoryMB = maxMemory
                                )
                            }
                        } catch (e: Exception) {
                            // Ignore memory read errors
                        }
                    }
                    
                    Thread.sleep(1000)
                }
            } catch (e: Exception) {
                log("Error in stats updater: ${e.message}")
            }
        }
    }
    
    /**
     * Start process monitor thread
     */
    private fun startProcessMonitor(serverProcess: ServerProcess) {
        log("Starting process monitor for: ${serverProcess.serverInfo.id}")
        
        Thread {
            try {
                val serverId = serverProcess.serverInfo.id
                log("Process monitor thread started")
                
                // Monitor process while alive
                while (serverProcess.process.isAlive) {
                    Thread.sleep(1000)
                    
                    // Check for forced stop
                    val currentState = ServerStateManager.getState(serverId)
                    if (currentState == ServerState.STOPPED || currentState == ServerState.ERROR) {
                        log("State mismatch detected: state=$currentState but process is alive")
                        serverProcess.process.destroyForcibly()
                        break
                    }
                }
                
                // Process has exited, wait for exit code
                val exitCode = serverProcess.process.waitFor()
                log("Process exited with code: $exitCode")
                
                val currentState = ServerStateManager.getState(serverId)
                if (currentState != ServerState.STOPPING) {
                    // Abnormal exit
                    log("Abnormal server exit detected")
                    ServerStateManager.updateState(serverId, ServerState.ERROR)
                    ServerStateManager.appendLog(serverId, "[CMSL] Server crashed with exit code: $exitCode")
                } else {
                    log("Normal server shutdown")
                    ServerStateManager.updateState(serverId, ServerState.STOPPED)
                }
                
                // Ensure state update propagates
                Thread.sleep(500)
                
                // Remove from running list
                runningServers.remove(serverId)
                log("Server removed from running list: $serverId")
                
                // Final confirmation of STOPPED state
                ServerStateManager.updateState(serverId, ServerState.STOPPED)
                log("Final state set to STOPPED")
            } catch (e: Exception) {
                log("Error in process monitor: ${e.message}")
                e.printStackTrace()
                ServerStateManager.updateState(serverProcess.serverInfo.id, ServerState.ERROR)
            }
        }.apply {
            name = "ProcessMonitor-${serverProcess.serverInfo.id}"
            isDaemon = true
        }.start()
    }
    
    /**
     * Stop all servers
     */
    suspend fun stopAllServers() {
        log("Stopping all servers...")
        val serverIds = runningServers.keys.toList()
        log("Total servers to stop: ${serverIds.size}")
        serverIds.forEach { serverId ->
            stopServer(serverId)
        }
        log("All servers stopped")
    }
}