package byd.cxkcxkckx.mcserver.utils

import byd.cxkcxkckx.mcserver.data.ServerConfig
import byd.cxkcxkckx.mcserver.data.ServerInfo
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.withContext
import java.io.BufferedReader
import java.io.BufferedWriter
import java.io.File
import java.io.InputStreamReader
import java.io.OutputStreamWriter

enum class ServerState {
    STOPPED,
    STARTING,
    RUNNING,
    STOPPING,
    ERROR
}

data class ServerProcess(
    val serverInfo: ServerInfo,
    val process: Process,
    val outputReader: BufferedReader,
    val inputWriter: BufferedWriter,
    val state: MutableStateFlow<ServerState> = MutableStateFlow(ServerState.STARTING),
    val logs: MutableStateFlow<List<String>> = MutableStateFlow(emptyList())
)

object ServerRunner {
    private val runningServers = mutableMapOf<String, ServerProcess>()
    private const val DEBUG = true // Enable debug logging
    
    private fun log(message: String) {
        if (DEBUG) {
            println("[ServerRunner] $message")
        }
    }
    
    /**
     * Check if EULA is accepted
     */
    suspend fun checkEula(serverPath: String): Boolean = withContext(Dispatchers.IO) {
        log("Checking EULA at: $serverPath")
        val eulaFile = File(serverPath, "eula.txt")
        if (!eulaFile.exists()) {
            log("EULA file not found")
            return@withContext false
        }
        
        try {
            val content = eulaFile.readText()
            val accepted = content.contains("eula=true", ignoreCase = true)
            log("EULA accepted: $accepted")
            return@withContext accepted
        } catch (e: Exception) {
            log("Error reading EULA: ${e.message}")
            return@withContext false
        }
    }
    
    /**
     * Accept EULA and write to file
     */
    suspend fun acceptEula(serverPath: String): Boolean = withContext(Dispatchers.IO) {
        log("Accepting EULA at: $serverPath")
        val eulaFile = File(serverPath, "eula.txt")
        try {
            val content = buildString {
                appendLine("# By changing the setting below to TRUE you are indicating your agreement to our EULA (https://www.minecraft.net/zh-hans/eula).")
                appendLine("# Generated by Cosp Minecraft Server Launcher")
                appendLine("# ${java.time.LocalDateTime.now()}")
                appendLine("eula=true")
            }
            eulaFile.writeText(content)
            log("EULA accepted successfully")
            return@withContext true
        } catch (e: Exception) {
            log("Error accepting EULA: ${e.message}")
            e.printStackTrace()
            return@withContext false
        }
    }
    
    /**
     * Start server
     */
    suspend fun startServer(serverInfo: ServerInfo): Result<ServerProcess> = withContext(Dispatchers.IO) {
        log("Starting server: ${serverInfo.name} (${serverInfo.id})")
        
        try {
            // Check if server is already running
            if (runningServers.containsKey(serverInfo.id)) {
                log("Server already running: ${serverInfo.id}")
                return@withContext Result.failure(Exception("Server already running"))
            }
            
            // Check server directory
            val serverDir = File(serverInfo.path)
            if (!serverDir.exists() || !serverDir.isDirectory) {
                log("Server directory not found: ${serverInfo.path}")
                return@withContext Result.failure(Exception("Server directory not found"))
            }
            log("Server directory: ${serverDir.absolutePath}")
            
            // Find server JAR file
            val jarFile = findServerJar(serverDir)
            if (jarFile == null || !jarFile.exists()) {
                log("Server JAR file not found in: ${serverDir.absolutePath}")
                return@withContext Result.failure(Exception("Server JAR file not found"))
            }
            log("Found server JAR: ${jarFile.name}")
            
            // Build start command
            val command = serverInfo.config.generateStartCommand(jarFile.name)
            log("Start command: ${command.joinToString(" ")}")
            
            // Create process
            val processBuilder = ProcessBuilder(command)
                .directory(serverDir)
                .redirectErrorStream(true)
            
            log("Starting process...")
            val process = processBuilder.start()
            log("Process started, PID: ${process.pid()}")
            
            // Create input/output streams
            val outputReader = BufferedReader(InputStreamReader(process.inputStream, Charsets.UTF_8))
            val inputWriter = BufferedWriter(OutputStreamWriter(process.outputStream, Charsets.UTF_8))
            log("I/O streams created")
            
            // Create server process object
            val serverProcess = ServerProcess(
                serverInfo = serverInfo,
                process = process,
                outputReader = outputReader,
                inputWriter = inputWriter
            )
            
            // Add to running list
            runningServers[serverInfo.id] = serverProcess
            log("Server added to running list: ${serverInfo.id}")
            
            // Start log reader coroutine
            startLogReader(serverProcess)

            // Start process monitor coroutine
            startProcessMonitor(serverProcess)

            // Wait briefly to determine if the server actually starts or exits immediately
            log("Server startup initiated, waiting for confirmation...")
            var waited = 0
            val maxWaitSeconds = 8
            while (waited < maxWaitSeconds) {
                // If the process has become RUNNING, return success
                if (serverProcess.state.value == ServerState.RUNNING) {
                    log("Server started successfully")
                    return@withContext Result.success(serverProcess)
                }

                // If process has already exited, consider it a failure
                if (!serverProcess.process.isAlive) {
                    log("Process exited prematurely during startup")
                    // collect last logs for context
                    val lastLogs = serverProcess.logs.value.takeLast(20).joinToString("\n")
                    return@withContext Result.failure(Exception("Server process exited during startup. Recent logs:\n$lastLogs"))
                }

                Thread.sleep(1000)
                waited++
            }

            // If still starting after timeout, return success but UI should continue to observe state flows
            log("Server still starting after $maxWaitSeconds seconds; returning startup pending")
            return@withContext Result.success(serverProcess)
        } catch (e: Exception) {
            log("Error starting server: ${e.message}")
            e.printStackTrace()
            return@withContext Result.failure(e)
        }
    }
    
    /**
     * Stop server
     */
    suspend fun stopServer(serverId: String): Boolean = withContext(Dispatchers.IO) {
        log("Stopping server: $serverId")
        val serverProcess = runningServers[serverId] ?: run {
            log("Server not found in running list: $serverId")
            return@withContext false
        }
        
        try {
            serverProcess.state.value = ServerState.STOPPING
            log("Server state set to STOPPING")
            
            // Send stop command
            sendCommand(serverId, "stop")
            log("Stop command sent")
            
            // Wait for process to end (max 30 seconds)
            var waitTime = 0
            while (serverProcess.process.isAlive && waitTime < 30) {
                Thread.sleep(1000)
                waitTime++
                if (waitTime % 5 == 0) {
                    log("Waiting for server to stop... ${waitTime}s")
                }
            }
            
            // Force kill if still alive
            if (serverProcess.process.isAlive) {
                log("Server did not stop gracefully, forcing termination")
                serverProcess.process.destroyForcibly()
            } else {
                log("Server stopped gracefully")
            }
            
            // Close streams
            try {
                serverProcess.outputReader.close()
                serverProcess.inputWriter.close()
                log("I/O streams closed")
            } catch (e: Exception) {
                log("Error closing streams: ${e.message}")
            }
            
            // Remove from running list
            runningServers.remove(serverId)
            log("Server removed from running list")
            
            serverProcess.state.value = ServerState.STOPPED
            log("Server state set to STOPPED")
            
            return@withContext true
        } catch (e: Exception) {
            log("Error stopping server: ${e.message}")
            e.printStackTrace()
            serverProcess.state.value = ServerState.ERROR
            return@withContext false
        }
    }
    
    /**
     * Send command to server
     */
    suspend fun sendCommand(serverId: String, command: String): Boolean = withContext(Dispatchers.IO) {
        log("Sending command to $serverId: $command")
        val serverProcess = runningServers[serverId] ?: run {
            log("Server not found: $serverId")
            return@withContext false
        }
        
        try {
            serverProcess.inputWriter.write(command)
            serverProcess.inputWriter.newLine()
            serverProcess.inputWriter.flush()
            log("Command sent successfully")
            return@withContext true
        } catch (e: Exception) {
            log("Error sending command: ${e.message}")
            e.printStackTrace()
            return@withContext false
        }
    }
    
    /**
     * Get server process
     */
    fun getServerProcess(serverId: String): ServerProcess? {
        return runningServers[serverId]
    }
    
    /**
     * Get server state
     */
    fun getServerState(serverId: String): StateFlow<ServerState>? {
        return runningServers[serverId]?.state
    }
    
    /**
     * Get server logs
     */
    fun getServerLogs(serverId: String): StateFlow<List<String>>? {
        return runningServers[serverId]?.logs
    }
    
    /**
     * Check if server is running
     */
    fun isServerRunning(serverId: String): Boolean {
        val process = runningServers[serverId]
        return process != null && process.process.isAlive
    }
    
    /**
     * Find server JAR file
     */
    private fun findServerJar(serverDir: File): File? {
        log("Searching for server JAR in: ${serverDir.absolutePath}")
        
        // Priority: server.jar
        val serverJar = File(serverDir, "server.jar")
        if (serverJar.exists()) {
            log("Found server.jar")
            return serverJar
        }
        
        // Find other JAR files
        val jarFiles = serverDir.listFiles { file ->
            file.extension.equals("jar", ignoreCase = true) &&
            !file.name.contains("libraries", ignoreCase = true)
        }
        
        log("Found ${jarFiles?.size ?: 0} JAR files")
        jarFiles?.forEach { log("  - ${it.name}") }
        
        return jarFiles?.firstOrNull()
    }
    
    /**
     * Start log reader
     */
    private fun startLogReader(serverProcess: ServerProcess) {
        log("Starting log reader for: ${serverProcess.serverInfo.id}")
        
        Thread {
            try {
                val logs = mutableListOf<String>()
                var line: String?
                var lineCount = 0
                
                log("Log reader thread started")
                
                while (serverProcess.process.isAlive) {
                    line = serverProcess.outputReader.readLine()
                    if (line != null) {
                        lineCount++
                        logs.add(line)
                        
                        // Only keep last 1000 lines
                        if (logs.size > 1000) {
                            logs.removeAt(0)
                        }
                        serverProcess.logs.value = logs.toList()
                        
                        // Log every 10 lines for debugging
                        if (lineCount % 10 == 0) {
                            log("Read $lineCount lines so far")
                        }
                        
                        // Detect server startup completion - multiple patterns
                        val lowerLine = line.lowercase()
                        if ((lowerLine.contains("done") && lowerLine.contains("for help")) ||
                            lowerLine.contains("timings reset") ||
                            (lowerLine.contains("done") && lowerLine.contains("(") && lowerLine.contains("s)")) ||
                            lowerLine.contains("server started")) {
                            
                            log("Server startup detected! State: ${serverProcess.state.value}")
                            log("Trigger line: $line")
                            
                            if (serverProcess.state.value == ServerState.STARTING) {
                                serverProcess.state.value = ServerState.RUNNING
                                log("Server state changed to RUNNING")
                            }
                        }
                    } else {
                        // End of stream
                        log("End of log stream reached")
                        break
                    }
                }
                
                log("Log reader thread ending, total lines read: $lineCount")
            } catch (e: Exception) {
                log("Error in log reader: ${e.message}")
                e.printStackTrace()
            }
        }.apply {
            name = "LogReader-${serverProcess.serverInfo.id}"
            isDaemon = true
        }.start()
    }
    
    /**
     * Start process monitor
     */
    private fun startProcessMonitor(serverProcess: ServerProcess) {
        log("Starting process monitor for: ${serverProcess.serverInfo.id}")
        
        Thread {
            try {
                log("Process monitor thread started")
                val exitCode = serverProcess.process.waitFor()
                log("Process exited with code: $exitCode")
                
                if (serverProcess.state.value != ServerState.STOPPING) {
                    // Abnormal exit
                    log("Abnormal server exit detected")
                    serverProcess.state.value = ServerState.ERROR
                    val errorLog = "[CMSL] Server crashed with exit code: $exitCode"
                    val logs = serverProcess.logs.value.toMutableList()
                    logs.add(errorLog)
                    serverProcess.logs.value = logs
                } else {
                    log("Normal server shutdown")
                    serverProcess.state.value = ServerState.STOPPED
                }
                
                // Remove from running list
                runningServers.remove(serverProcess.serverInfo.id)
                log("Server removed from running list: ${serverProcess.serverInfo.id}")
            } catch (e: Exception) {
                log("Error in process monitor: ${e.message}")
                e.printStackTrace()
                serverProcess.state.value = ServerState.ERROR
            }
        }.apply {
            name = "ProcessMonitor-${serverProcess.serverInfo.id}"
            isDaemon = true
        }.start()
    }
    
    /**
     * Stop all servers
     */
    suspend fun stopAllServers() {
        log("Stopping all servers...")
        val serverIds = runningServers.keys.toList()
        log("Total servers to stop: ${serverIds.size}")
        serverIds.forEach { serverId ->
            stopServer(serverId)
        }
        log("All servers stopped")
    }
}
