package byd.cxkcxkckx.mcserver.utils

import byd.cxkcxkckx.mcserver.data.ServerConfig
import byd.cxkcxkckx.mcserver.data.ServerInfo
import byd.cxkcxkckx.mcserver.data.ServerStats
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.withContext
import java.io.BufferedReader
import java.io.BufferedWriter
import java.io.File
import java.io.InputStreamReader
import java.io.OutputStreamWriter
import java.nio.charset.Charset
import kotlin.concurrent.thread

enum class ServerState {
    STOPPED,
    STARTING,
    RUNNING,
    STOPPING,
    ERROR
}

data class ServerProcess(
    val serverInfo: ServerInfo,
    val process: Process,
    val outputReader: BufferedReader,
    val inputWriter: BufferedWriter,
    val state: MutableStateFlow<ServerState> = MutableStateFlow(ServerState.STARTING),
    val logs: MutableStateFlow<List<String>> = MutableStateFlow(emptyList()),
    val stats: MutableStateFlow<ServerStats> = MutableStateFlow(ServerStats()),
    var startTime: Long = System.currentTimeMillis()
)

object ServerRunner {
    private val runningServers = mutableMapOf<String, ServerProcess>()
    private const val DEBUG = true // Enable debug logging
    // 自动检测系统编码
    private val systemCharset: Charset = run {
        val osName = System.getProperty("os.name").lowercase()
        when {
            osName.contains("windows") -> {
                try {
                    Charset.forName("GBK")
                } catch (e: Exception) {
                    Charsets.UTF_8
                }
            }
            else -> Charsets.UTF_8
        }
    }
    
    private fun log(message: String) {
        if (DEBUG) {
            println("[ServerRunner] $message")
        }
    }
    
    /**
     * Check if EULA is accepted
     */
    suspend fun checkEula(serverPath: String): Boolean = withContext(Dispatchers.IO) {
        log("Checking EULA at: $serverPath")
        val eulaFile = File(serverPath, "eula.txt")
        if (!eulaFile.exists()) {
            log("EULA file not found")
            return@withContext false
        }
        
        try {
            val content = eulaFile.readText()
            val accepted = content.contains("eula=true", ignoreCase = true)
            log("EULA accepted: $accepted")
            return@withContext accepted
        } catch (e: Exception) {
            log("Error reading EULA: ${e.message}")
            return@withContext false
        }
    }
    
    /**
     * Accept EULA and write to file
     */
    suspend fun acceptEula(serverPath: String): Boolean = withContext(Dispatchers.IO) {
        log("Accepting EULA at: $serverPath")
        val eulaFile = File(serverPath, "eula.txt")
        try {
            val content = buildString {
                appendLine("# By changing the setting below to TRUE you are indicating your agreement to our EULA (https://www.minecraft.net/zh-hans/eula).")
                appendLine("# Generated by Cosp Minecraft Server Launcher")
                appendLine("# ${java.time.LocalDateTime.now()}")
                appendLine("eula=true")
            }
            eulaFile.writeText(content)
            log("EULA accepted successfully")
            return@withContext true
        } catch (e: Exception) {
            log("Error accepting EULA: ${e.message}")
            e.printStackTrace()
            return@withContext false
        }
    }
    
    /**
     * Start server
     */
    suspend fun startServer(serverInfo: ServerInfo): Result<ServerProcess> = withContext(Dispatchers.IO) {
        log("Starting server: ${serverInfo.name} (${serverInfo.id})")
        log("System charset: ${systemCharset.name()}")
        
        try {
            // Check if server is already running
            if (runningServers.containsKey(serverInfo.id)) {
                log("Server already running: ${serverInfo.id}")
                return@withContext Result.failure(Exception("Server already running"))
            }
            
            // Check server directory
            val serverDir = File(serverInfo.path)
            if (!serverDir.exists() || !serverDir.isDirectory) {
                log("Server directory not found: ${serverInfo.path}")
                return@withContext Result.failure(Exception("Server directory not found"))
            }
            log("Server directory: ${serverDir.absolutePath}")
            
            // Find server JAR file
            val jarFile = findServerJar(serverDir)
            if (jarFile == null || !jarFile.exists()) {
                log("Server JAR file not found in: ${serverDir.absolutePath}")
                return@withContext Result.failure(Exception("Server JAR file not found"))
            }
            log("Found server JAR: ${jarFile.name}")
            
            // Build start command
            val command = serverInfo.config.generateStartCommand(jarFile.name)
            log("Start command: ${command.joinToString(" ")}")
            
            // Create process
            val processBuilder = ProcessBuilder(command)
                .directory(serverDir)
                .redirectErrorStream(true)

            // 设置环境变量以支持 UTF-8
            val env = processBuilder.environment()
            val osName = System.getProperty("os.name").lowercase()
            if (osName.contains("windows")) {
                // Windows 系统设置（尽量保持 JVM 输出为 UTF-8）
                env["JAVA_TOOL_OPTIONS"] = "-Dfile.encoding=UTF-8 -Dconsole.encoding=UTF-8 -Dsun.stdout.encoding=UTF-8 -Dsun.stderr.encoding=UTF-8"
            } else {
                // Linux/macOS 系统设置
                env["LANG"] = "zh_CN.UTF-8"
                env["LC_ALL"] = "zh_CN.UTF-8"
            }

            log("Starting process...")
            val process = processBuilder.start()
            log("Process started, PID: ${process.pid()}")

            // Create input/output streams with proper charset
            // 输出流（读取服务器日志）使用系统编码
            val outputReader = BufferedReader(InputStreamReader(process.inputStream, systemCharset))
            // 输入流（发送命令）也使用系统编码以确保兼容性
            val inputWriter = BufferedWriter(OutputStreamWriter(process.outputStream, systemCharset))
            log("I/O streams created with charset: ${systemCharset.name()}")
            
            // Create server process object
            val serverProcess = ServerProcess(
                serverInfo = serverInfo,
                process = process,
                outputReader = outputReader,
                inputWriter = inputWriter,
                startTime = System.currentTimeMillis()
            )
            
            // Add to running list
            runningServers[serverInfo.id] = serverProcess
            log("Server added to running list: ${serverInfo.id}")
            
            // Start log reader coroutine
            startLogReader(serverProcess)

            // Start process monitor coroutine
            startProcessMonitor(serverProcess)
            
            // Start stats updater
            startStatsUpdater(serverProcess)

            // Wait briefly to determine if the server actually starts or exits immediately
            log("Server startup initiated, waiting for confirmation...")
            var waited = 0
            val maxWaitSeconds = 8
            while (waited < maxWaitSeconds) {
                // If the process has become RUNNING, return success
                if (serverProcess.state.value == ServerState.RUNNING) {
                    log("Server started successfully")
                    return@withContext Result.success(serverProcess)
                }

                // If process has already exited, consider it a failure
                if (!serverProcess.process.isAlive) {
                    log("Process exited prematurely during startup")
                    // collect last logs for context
                    val lastLogs = serverProcess.logs.value.takeLast(20).joinToString("\n")
                    return@withContext Result.failure(Exception("Server process exited during startup. Recent logs:\n$lastLogs"))
                }

                Thread.sleep(1000)
                waited++
            }

            // If still starting after timeout, return success but UI should continue to observe state flows
            log("Server still starting after $maxWaitSeconds seconds; returning startup pending")
            return@withContext Result.success(serverProcess)
        } catch (e: Exception) {
            log("Error starting server: ${e.message}")
            e.printStackTrace()
            return@withContext Result.failure(e)
        }
    }
    
    /**
     * Stop server
     */
    suspend fun stopServer(serverId: String): Boolean = withContext(Dispatchers.IO) {
        log("Stopping server: $serverId")
        val serverProcess = runningServers[serverId] ?: run {
            log("Server not found in running list: $serverId")
            return@withContext false
        }
        
        try {
            serverProcess.state.value = ServerState.STOPPING
            log("Server state set to STOPPING")
            
            // Send stop command
            sendCommand(serverId, "stop")
            log("Stop command sent")
            
            // Wait for process to end (max 30 seconds)
            var waitTime = 0
            while (serverProcess.process.isAlive && waitTime < 30) {
                Thread.sleep(1000)
                waitTime++
                if (waitTime % 5 == 0) {
                    log("Waiting for server to stop... ${waitTime}s")
                }
            }
            
            // Force kill if still alive
            if (serverProcess.process.isAlive) {
                log("Server did not stop gracefully, forcing termination")
                serverProcess.process.destroyForcibly()
            } else {
                log("Server stopped gracefully")
            }
            
            // Close streams
            try {
                serverProcess.outputReader.close()
                serverProcess.inputWriter.close()
                log("I/O streams closed")
            } catch (e: Exception) {
                log("Error closing streams: ${e.message}")
            }
            
            // Remove from running list
            runningServers.remove(serverId)
            log("Server removed from running list")
            
            serverProcess.state.value = ServerState.STOPPED
            log("Server state set to STOPPED")
            
            return@withContext true
        } catch (e: Exception) {
            log("Error stopping server: ${e.message}")
            e.printStackTrace()
            serverProcess.state.value = ServerState.ERROR
            return@withContext false
        }
    }
    
    /**
     * Force kill server immediately
     */
    suspend fun forceKillServer(serverId: String): Boolean = withContext(Dispatchers.IO) {
        log("Force killing server: $serverId")
        val serverProcess = runningServers[serverId] ?: run {
            log("Server not found in running list: $serverId")
            return@withContext false
        }
        
        try {
            // Force kill process immediately
            if (serverProcess.process.isAlive) {
                log("Force terminating process")
                serverProcess.process.destroyForcibly()
                
                // Wait up to 5 seconds for the process to die
                var waited = 0
                while (serverProcess.process.isAlive && waited < 10) {
                    Thread.sleep(500)
                    waited++
                }
                log("Process force killed")
            }
            
            // Close streams
            try {
                serverProcess.outputReader.close()
                serverProcess.inputWriter.close()
                log("I/O streams closed")
            } catch (e: Exception) {
                log("Error closing streams: ${e.message}")
            }
            
            // Remove from running list
            runningServers.remove(serverId)
            log("Server removed from running list")
            
            serverProcess.state.value = ServerState.STOPPED
            log("Server state set to STOPPED")
            
            return@withContext true
        } catch (e: Exception) {
            log("Error force killing server: ${e.message}")
            e.printStackTrace()
            serverProcess.state.value = ServerState.ERROR
            return@withContext false
        }
    }
    
    /**
     * Send command to server
     */
    suspend fun sendCommand(serverId: String, command: String): Boolean = withContext(Dispatchers.IO) {
        log("Sending command to $serverId: $command")
        val serverProcess = runningServers[serverId] ?: run {
            log("Server not found: $serverId")
            return@withContext false
        }
        
        try {
            serverProcess.inputWriter.write(command)
            serverProcess.inputWriter.newLine()
            serverProcess.inputWriter.flush()
            log("Command sent successfully")
            return@withContext true
        } catch (e: Exception) {
            log("Error sending command: ${e.message}")
            e.printStackTrace()
            return@withContext false
        }
    }
    
    /**
     * Get server process
     */
    fun getServerProcess(serverId: String): ServerProcess? {
        return runningServers[serverId]
    }
    
    /**
     * Get server state
     */
    fun getServerState(serverId: String): StateFlow<ServerState>? {
        return runningServers[serverId]?.state
    }
    
    /**
     * Get server logs
     */
    fun getServerLogs(serverId: String): StateFlow<List<String>>? {
        return runningServers[serverId]?.logs
    }
    
    /**
     * Get server stats
     */
    fun getServerStats(serverId: String): StateFlow<ServerStats>? {
        return runningServers[serverId]?.stats
    }
    
    /**
     * Check if server is running
     */
    fun isServerRunning(serverId: String): Boolean {
        val process = runningServers[serverId]
        return process != null && process.process.isAlive
    }
    
    /**
     * Find server JAR file
     */
    private fun findServerJar(serverDir: File): File? {
        log("Searching for server JAR in: ${serverDir.absolutePath}")
        
        // Priority: server.jar
        val serverJar = File(serverDir, "server.jar")
        if (serverJar.exists()) {
            log("Found server.jar")
            return serverJar
        }
        
        // Find other JAR files
        val jarFiles = serverDir.listFiles { file ->
            file.extension.equals("jar", ignoreCase = true) &&
            !file.name.contains("libraries", ignoreCase = true)
        }
        
        log("Found ${jarFiles?.size ?: 0} JAR files")
        jarFiles?.forEach { log("  - ${it.name}") }
        
        return jarFiles?.firstOrNull()
    }
    
    /**
     * Start log reader
     */
    private fun startLogReader(serverProcess: ServerProcess) {
        log("Starting log reader for: ${serverProcess.serverInfo.id}")
        
        Thread {
            try {
                val logs = mutableListOf<String>()
                var line: String?
                var lineCount = 0
                
                log("Log reader thread started")
                
                while (serverProcess.process.isAlive) {
                    line = serverProcess.outputReader.readLine()
                    if (line != null) {
                        lineCount++
                        logs.add(line)
                        
                        // Only keep last 1000 lines
                        if (logs.size > 1000) {
                            logs.removeAt(0)
                        }
                        serverProcess.logs.value = logs.toList()
                        
                        // Log every 10 lines for debugging
                        if (lineCount % 10 == 0) {
                            log("Read $lineCount lines so far")
                        }
                        
                        // Detect server startup completion - multiple patterns
                        val lowerLine = line.lowercase()
                        if ((lowerLine.contains("done") && lowerLine.contains("for help")) ||
                            lowerLine.contains("timings reset") ||
                            (lowerLine.contains("done") && lowerLine.contains("(") && lowerLine.contains("s)")) ||
                            lowerLine.contains("server started")) {
                            
                            log("Server startup detected! State: ${serverProcess.state.value}")
                            log("Trigger line: $line")
                            
                            if (serverProcess.state.value == ServerState.STARTING) {
                                serverProcess.state.value = ServerState.RUNNING
                                log("Server state changed to RUNNING")
                            }
                        }
                        
                        // Parse player events
                        parsePlayerEvents(line, serverProcess)
                        
                        // Parse TPS information
                        parseTpsInfo(line, serverProcess)
                        
                        // Parse memory info
                        parseMemoryInfo(line, serverProcess)
                    } else {
                        // End of stream
                        log("End of log stream reached")
                        break
                    }
                }
                
                log("Log reader thread ending, total lines read: $lineCount")
            } catch (e: Exception) {
                log("Error in log reader: ${e.message}")
                e.printStackTrace()
            }
        }.apply {
            name = "LogReader-${serverProcess.serverInfo.id}"
            isDaemon = true
        }.start()
    }
    
    /**
     * Parse player join/leave events from logs
     */
    private fun parsePlayerEvents(line: String, serverProcess: ServerProcess) {
        try {
            val lowerLine = line.lowercase()
            
            // Player joined
            if (lowerLine.contains("joined the game") || lowerLine.contains("logged in")) {
                val current = serverProcess.stats.value
                serverProcess.stats.value = current.copy(
                    onlinePlayers = (current.onlinePlayers + 1).coerceAtMost(current.maxPlayers)
                )
                log("Player joined, online: ${serverProcess.stats.value.onlinePlayers}")
            }
            
            // Player left
            if (lowerLine.contains("left the game") || lowerLine.contains("logged out") || 
                lowerLine.contains("disconnected")) {
                val current = serverProcess.stats.value
                serverProcess.stats.value = current.copy(
                    onlinePlayers = (current.onlinePlayers - 1).coerceAtLeast(0)
                )
                log("Player left, online: ${serverProcess.stats.value.onlinePlayers}")
            }
            
            // Parse max players from server.properties loading message
            // Example: "Max players: 20"
            val maxPlayersMatch = Regex("max.*players.*[:\\s]+(\\d+)", RegexOption.IGNORE_CASE).find(line)
            if (maxPlayersMatch != null) {
                val maxPlayers = maxPlayersMatch.groupValues[1].toIntOrNull()
                if (maxPlayers != null) {
                    val current = serverProcess.stats.value
                    serverProcess.stats.value = current.copy(maxPlayers = maxPlayers)
                    log("Max players set to: $maxPlayers")
                }
            }
        } catch (e: Exception) {
            // Ignore parse errors
        }
    }
    
    /**
     * Parse TPS information from logs
     */
    private fun parseTpsInfo(line: String, serverProcess: ServerProcess) {
        try {
            // TPS from /tps command or Paper's TPS message
            // Example: "TPS from last 1m, 5m, 15m: 20.0, 20.0, 20.0"
            // Example: "Current TPS = 20.0"
            val tpsMatch = Regex("tps.*?([0-9]+\\.[0-9]+)", RegexOption.IGNORE_CASE).find(line)
            if (tpsMatch != null) {
                val tps = tpsMatch.groupValues[1].toDoubleOrNull()
                if (tps != null && tps <= 20.0) {
                    val current = serverProcess.stats.value
                    serverProcess.stats.value = current.copy(tps = tps)
                    log("TPS updated: $tps")
                }
            }
        } catch (e: Exception) {
            // Ignore parse errors
        }
    }
    
    /**
     * Parse memory information from logs
     */
    private fun parseMemoryInfo(line: String, serverProcess: ServerProcess) {
        try {
            // Memory from various sources
            // Example: "Memory: 512M/2048M"
            // Example: "Used memory: 512 MB / Total: 2048 MB"
            val memoryMatch = Regex("(\\d+)\\s*(?:m|mb).*?(\\d+)\\s*(?:m|mb|g|gb)", RegexOption.IGNORE_CASE).find(line)
            if (memoryMatch != null) {
                val used = memoryMatch.groupValues[1].toLongOrNull()
                val total = memoryMatch.groupValues[2].toLongOrNull()
                if (used != null && total != null) {
                    val current = serverProcess.stats.value
                    serverProcess.stats.value = current.copy(
                        usedMemoryMB = used,
                        maxMemoryMB = if (total > 100) total else total * 1024 // Convert GB to MB if needed
                    )
                    log("Memory updated: ${used}MB / ${total}MB")
                }
            }
        } catch (e: Exception) {
            // Ignore parse errors
        }
    }
    
    /**
     * Start stats updater thread
     */
    private fun startStatsUpdater(serverProcess: ServerProcess) {
        thread(name = "StatsUpdater-${serverProcess.serverInfo.id}", isDaemon = true) {
            try {
                while (serverProcess.process.isAlive) {
                    // Update uptime every second
                    val uptimeSeconds = (System.currentTimeMillis() - serverProcess.startTime) / 1000
                    val current = serverProcess.stats.value
                    serverProcess.stats.value = current.copy(uptimeSeconds = uptimeSeconds)
                    
                    // Get memory info from JVM
                    try {
                        val runtime = Runtime.getRuntime()
                        val usedMemory = (runtime.totalMemory() - runtime.freeMemory()) / (1024 * 1024)
                        val maxMemory = runtime.maxMemory() / (1024 * 1024)
                        
                        if (current.maxMemoryMB == 0L) {
                            serverProcess.stats.value = current.copy(
                                usedMemoryMB = usedMemory,
                                maxMemoryMB = maxMemory,
                                uptimeSeconds = uptimeSeconds
                            )
                        } else {
                            serverProcess.stats.value = current.copy(uptimeSeconds = uptimeSeconds)
                        }
                    } catch (e: Exception) {
                        // Ignore memory read errors
                    }
                    
                    Thread.sleep(1000)
                }
            } catch (e: Exception) {
                log("Error in stats updater: ${e.message}")
            }
        }
    }
    
    /**
     * Start process monitor
     */
    private fun startProcessMonitor(serverProcess: ServerProcess) {
        log("Starting process monitor for: ${serverProcess.serverInfo.id}")
        
        Thread {
            try {
                log("Process monitor thread started")
                val exitCode = serverProcess.process.waitFor()
                log("Process exited with code: $exitCode")
                
                if (serverProcess.state.value != ServerState.STOPPING) {
                    // Abnormal exit
                    log("Abnormal server exit detected")
                    serverProcess.state.value = ServerState.ERROR
                    val errorLog = "[CMSL] Server crashed with exit code: $exitCode"
                    val logs = serverProcess.logs.value.toMutableList()
                    logs.add(errorLog)
                    serverProcess.logs.value = logs
                } else {
                    log("Normal server shutdown")
                    serverProcess.state.value = ServerState.STOPPED
                }
                
                // Remove from running list
                runningServers.remove(serverProcess.serverInfo.id)
                log("Server removed from running list: ${serverProcess.serverInfo.id}")
            } catch (e: Exception) {
                log("Error in process monitor: ${e.message}")
                e.printStackTrace()
                serverProcess.state.value = ServerState.ERROR
            }
        }.apply {
            name = "ProcessMonitor-${serverProcess.serverInfo.id}"
            isDaemon = true
        }.start()
    }
    
    /**
     * Stop all servers
     */
    suspend fun stopAllServers() {
        log("Stopping all servers...")
        val serverIds = runningServers.keys.toList()
        log("Total servers to stop: ${serverIds.size}")
        serverIds.forEach { serverId ->
            stopServer(serverId)
        }
        log("All servers stopped")
    }
}
